### 1、词法作用域和动态作用域

`词法作用域`也称`静态作用域`，是指函数在定义的时候就确定了，不会随着调用上下文的改变而改变作用域。js采用的就是词法作用域。

而`动态作用域`是指函数的作用域是在函数调用的时候才决定的。

```javascript
// 下面是js权威指南的例子
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();


var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

通过打印可以看出结果都是`local scope`，因为函数的执行用到了作用域链，这是在定义时就创建好了的。如果是动态作用域的，下面的函数就会打印出`global scope`

### 2、理解 `JavaScript`的作用域和作用域链

作用域就是定义变量的执行范围，实际就是执行代码对变量的访问权限。

作用域分为三种：

- 全局作用域
- 函数作用域
- 块级作用域(es6新增，使用let/const声明)

js采用的是词法作用域，会优先寻找定义变量的地方，而不是执行的地方，当所在作用域找不到合适的变量时，就会向上寻找，知道全局变量，找不到则报错，这种向上寻找变量的过程就叫做作用域链。

### 3、理解 `JavaScript`的执行上下文栈，可以应用堆栈信息快速定位问题

执行上下文就是代码运行时所在的环境，是一个抽象的概念。它分为三种：

- 全局执行上下文
- 函数执行上下文
- eval函数执行上下文

全局执行上下文只有一个，一般指`window`,我们通常说的最多的执行上下文是指函数执行上下文，这些上下文会在函数被调用时创建。

**栈**是一种先进后出的数据结构。而js是单线程的开发语言，会按照顺序执行一系列语句，每当调用一个函数时，会创建一个上下文，并且压入栈中(push)，当调用完后会被回收弹出栈(pop)。通过`debugger`断点调试在浏览器的`Sources`选项卡的`Call Stack`查看当前执行上下文

### 4、`this`的原理以及几种不同使用场景的取值

我们使用的`this`关键字都是在函数内部用的，函数有不同的使用场景，不同的场景有不同的执行上下文，可以看出函数是一个独立的对象，它内部的执行上下文由它当前执行环境所决定，而`this`就是用来代替执行上下文的。每个函数初始化的时候都会调用函数内部对象的`[[call]](thisArgument,argumentlist)`，thisArgument就是指代this,如果thisArgument没有传递，this就是当前执行环境上下文，传递了并且不为null、undefined，this的绑定值就是thisArgument。

**场景**：

- 剪头函数。由定义时的上下文决定
- 普通函数。this指向window。
- 作为对象的属性。this指向调用对象
- call、apply、bind。this由传入的第一个参数决定
- 构造函数。this指向构造函数实例化的对象

### 5、闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

**闭包**就是在一个函数作用域内，另一个调用/执行的函数可以访问到当前函数作用域的变量，由函数和词语作用域组合构成。

作用：可以保持变量不被销毁一直保存在内存中，反复使用

实际应用：表格的列拼接。表格有默认的展示列，还有根据系统配置需要加上去的列，当时有额外一些列，需要根据配置项是否展示，于是将默认的列放在函数内部，返回一个函数去拼接新的列。

```javascript
function getColumn() {
  let defaultColumn = [{},{}];
  return getNewColumn(columns = []) {
    defaultColumn = defaultColumn.concat(columns);
    return defaultColumn;
  }
}

const columnFn = getColumn();
 let columns = columnFn();
// 配置1
columns = columnFn([{}]);
// 配置2
columns = columnFn([{}]);
```

此外还有定时器循环拿到对应的值、私用变量、防抖等

### 6、理解堆栈溢出和内存泄漏的原理，如何防止

在计算机中，每声明一个变量或者函数，都会分配一块内存，而内存是有限的，所以需要进行及时的处理。

**堆栈溢出**是指当函数调用的信息超出了栈内存的空间大小。调用执行栈空间是有限的，每个上下文执行栈是有生命周期的，分为：创建阶段、使用阶段、销毁阶段。当执行栈执行完后会等待被执行回收，如果创建执行栈的速度超过销毁阶段的回收速度，就会造成溢出。

**内存泄漏**是指分配的内存空间占用了，但是已经用完了，但是没有及时释放，导致内存空间越来越大。

防止：

- 避免函数进入死循环
- 不要滥用闭包
- 尽可能的少使用全局变量

### 7、如何处理循环的异步操作

根据实际场景决定。

- 如果是promise的话可以使用Promise.all()
- 也可以初始化一个变量，每循环一次自增，当变量等于length时在执行下一步操作
- 把循环放在promise里执行

![](https://github.com/aWhver/for-PicGo/blob/master/images/eventloop-case.png)
