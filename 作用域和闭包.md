### 1、词法作用域和动态作用域

`词法作用域`也称`静态作用域`，是指函数在定义的时候就确定了，不会随着调用上下文的改变而改变作用域。js采用的就是词法作用域。

而`动态作用域`是指函数的作用域是在函数调用的时候才决定的。

```javascript
// 下面是js权威指南的例子
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();


var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

通过打印可以看出结果都是`local scope`，因为函数的执行用到了作用域链，这是在定义时就创建好了的。如果是动态作用域的，下面的函数就会打印出`global scope`

function uniq(arr) {
  if (arr.length <= 1) {return arr;}
  var left = [];
  var right = [];
  var middleIndex = Math.floor(arr.length/2);
  for (var i = 0;i<arr.length;i++) {
    if (i !== middleIndex) {
if (arr[i]<=arr[middleIndex]) {
      left.push(arr[i])
    } else {
      right.push(arr[i])
    }
    }

  }
  return arguments.callee(left).concat([arr[middleIndex]], arguments.callee(right));
};
uniq([1,2,3,4,5,68,3,2,1,2,5,9,4])

function uniq(arr) {

	// 如果数组长度小于一，直接返回该数组
	// [2,1]直接排序重组
	if (arr.length <= 1) {return arr;}

	// pivot ：中心点
	var pivotIndex = Math.floor(arr.length/2);
	// 左边的数组
	var left = [];
	var pivot = arr[pivotIndex];
	// 右边的数组
	var right = [];

	for (var i = 0; i < arr.length; i ++) {

		// 下标不是中间标线的才push
		// if(i !== pivotIndex) {
			if (arr[i] <= arr[pivotIndex]) {
				left.push(arr[i]);
			} else {
				// >=的类目全部压入
				right.push(arr[i]);
			}
		// }
	}

	// 这个是排序排一遍输出的结果
	// console.log(left.concat(pivot).concat(right))

	// 点睛之笔，递归的运用
	return arguments.callee(left).concat(arguments.callee(right));
}
uniq([1,2,3,4,5,68,3,2,1,2,5,9,4])