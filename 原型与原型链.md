### 1、理解原型设计模式以及 `JavaScript`中的原型规则

**原型设计模式**：

原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。

个人理解就是 js 继承的几种方式

- 构造函数模式。通过 new 一个构造函数得到一个对象`obj`，obj 可以访问到构造函数下的定义的方法和属性
- 原型模式。直接将对象 A 的 prototype 赋值给对象 B，可以得到方法和属性共享
- 工厂模式。在函数内创建一个对象，给对象赋予属性及方法再将对象返回

**原型规则**：

- 所有的引用类型(对象、函数、数组)，具有对象特征，可以自由扩展属性
- 每个引用类型都有一个隐式原型：`__proto__`，属性值是一个普通对象
- 每个所有函数都有属于自己的`prototype`属性(显示原型)，值是一个普通对象
- 构造函数的原型(prototype)等于构造函数实例化的对象的`__proto__`
- 当试图得到一个对象的属性/方法时，如果这个对象本身没有这个属性，那么会去它的**proto**（即它的构造函数的 prototype）中去寻找
- 每个构造函数的`prototype`的`constructor`属性默认等于构造函数本身

### 2、instanceof 底层实现原理，手动实现一个 instanceof

原理：instanceof 左边一般是实例化后的对象或者构造函数，右边是构造函数，如果一个对象是某个类型的实例，就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例

```javascript
  function mockInstancof(leftValue, rightValue) {
    var rightPrototype = rightValue.prototype;
    var leftProto = leftValue.__proto__;
    while (true) {
      if (leftProto === null) {
        return false;
      }
      if (rightPrototype === leftProto) {
        return true;
      }
      leftProto = leftProto.__proto__;
    }
  }
```
